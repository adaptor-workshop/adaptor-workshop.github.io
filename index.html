<!DOCTYPE html>
<html>
<head>
  <style>
    * {
    box-sizing: border-box;
  }
  body {
    font-family: Arial, Helvetica, sans-serif;
    padding: 50px;
    background: #f1f1f1;
    }
  /* Header/Blog Title */
  .header {
    padding: 20px;
    text-align: center;
    background: #21618C; /*white;*/
    color: #F4F6F7;
  }
  .header h1 {
  font-size: 32px;
  font-weight:normal;
  }
  .header h2 {
  font-size: 25px;
  font-weight:normal;
  color: #DDF2FB;
  }
  .header h3 {
  font-size: 20px;
  font-weight:normal;
  color: #D0D3D4;
  }
  .header h4 {
  font-size: 32px;
  font-weight:bold;
  color: #DDF2FB;
  }
  .content {
    text-align: justify;
  }
  .content h2 {
  font-size: 30px;
  }  

  .talk-description { 
    list-style-position: inside;
    padding-left: 0;
  }

  /* Style the tab */
  .tab {
    overflow: hidden;
    border: 1px solid #ccc;
    background-color: #CACFD2;
  }

  /* Style the buttons inside the tab */
  .tab button {
    background-color: inherit;
    float: left;
    border: none;
    outline: none;
    cursor: pointer;
    padding: 14px 16px;
    transition: 0.3s;
    font-size: 17px;
  }

  /* Change background color of buttons on hover */
  .tab button:hover {
    background-color: #ddd;
  }

  /* Create an active/current tablink class */
  .tab button.active {
    background-color: #ccc;
  }

  /* Style the buttons inside the tab */
  .tab a {
    text-decoration: none;
    color: initial;
    background-color: inherit;
    float: left;
    border: none;
    outline: none;
    cursor: pointer;
    padding: 14px 16px;
    transition: 0.3s;
    font-size: 17px;
  }

  /* Change background color of buttons on hover */
  .tab a:hover {
    background-color: #ddd;
  }

  /* Style the tab content */
  .tabcontent {
    margin-left: 20px;
    margin-right: 20px;
    font-weight:normal;
    font-size: 17px;
  } 

  .tabcontent h1 {
    font-size: 20px;
    font-weight:bold;
  }

  .tabcontent h2 {
    margin-top: 30px;
    font-size: 20px;
    font-weight:normal;
  }

  .tabcontent h3 {
    margin-top: 30px;
    font-size: 20px;
    font-weight:bold;
  }

  .tabcontent h4 {
    /* margin-top: -10px; */
    /* margin-left: 20px; */
    margin-bottom: 0px;
    font-size: 16px;
    font-weight:bold;
    /* font-style:italic; */
  }

  .st table {
    width: 100%;
    table-layout: fixed;
  }

  .st tr:nth-child(odd) {
    background-color: #eae8eaaa;
  }

  .std {
    vertical-align: top;
  }

  .sr {
    width: 65%;
    font-size: 16px;
    font-weight:bold;
  }

  .sl {
    width: 35%;
    vertical-align: top;
    font-size: 16px;
  }

  .sr1 {
    font-weight: bold;
    font-size: 17px;
  }
  .sr1mute {
    font-weight: normal;
    font-size: 17px;
  }

  .sr2 {
    margin-top: 6px;
    font-size: 15px;
    font-weight: normal
  }

  .sr2mute {
    display: none;
    margin-top: 8px;
    font-size: 15px;
    font-weight: normal
  }

  .tabcontent h5 {
    margin-top: 8px;
    /* margin-left: 20px; */
    font-size: 15px;
    font-weight:normal;
  }

  .alink:link, .alink:visited {
   color:inherit;
}

  </style>
</head>

<body>


<div id="ADAPTOR" class="header">
  <h1> <b>ADAPTOR 2022</b> <h1>
  <h1> 1st Workshop on <b>A</b>ccelerator <b>D</b>esign <b>A</b>s <b>P</b>rovably Correc<b>t</b> S<b>o</b>ftwa<b>r</b>e</h1>
  <h2> October 1st 2022, Saturday, 1pm - 5pm CDT </h2>
  <h3> in conjunction with the 55th IEEE/ACM International Symposium on Microarchitecture (<a class="alink" href="https://www.microarch.org/micro55/">MICRO'22</a>) </h3> 
</div>


<div class="tab">
  <a class="tablinks" href="#ADAPTOR">Home</a>
  <a class="tablinks" href="#Program">Program</a> 
  <a class="tablinks" href="#Speakers">Invited Speakers and Talks Details</a>
  <a class="tablinks" href="#Venue">Venue</a>
  <a class="tablinks" href="#Organizers">Organizers</a>
</div>




<div id="Home" class="tabcontent">
  <h2> <b> ADAPTOR 2022 will be held in person in Chicago. 
    We will have invited speakers from industry and academia to share
    their pioneering work at the <em>intersection of accelerator architecture, design, and 
    verification.</em> </b> </h2>
</div>





<div id="Why" class="tabcontent">
  <h3>Hardware Accelerator meets Formal Verification</h3>
  <p>
    We are in a golden era of rapid accelerator architecture innovations driven by 
    emerging applications where the pure pursuit of FLOPS in hardware design with 
    generality and abstraction is being replaced with targeted specialization. 
    Hardware accelerators have become one of the most critical functional blocks 
    of modern heterogeneous computer architectures. 
    These accelerators implement domain-specific functions for machine learning and inference, 
    edge intelligence, secure computing, and so on to improve power efficiency and computation 
    throughput by several orders of magnitude. At the same time, the existing design practice 
    cannot keep up with the pace of innovations due to the exponentially increasing complexity 
    and cost. In particular, verification of functional correctness has become a major factor in 
    design complexity and cost, and the trend is worsening.
  </p>

  <p>This calls for a design paradigm shift including raising the level of abstraction in 
    hardware design to software, scalable and composable verification, and a new programming 
    model amenable for rapid verification, etc.
    Recent work presented at MICRO/ISCA/FMCAD/PLDI/POPL and other sister conferences indicates 
    a substantial number of researchers in the community with interests in the intersection of 
    accelerator architecture, design, and verification.
  </p> 

  

  <h3>Objectives of the Workshop</h3>

  <p>This workshop intends to provide a forum to bring researchers from domain-specific 
    languages and compilers, architecture, and formal methods communities with common 
    interests at the intersection of accelerator architecture, design, and 
    verification together to cross-pollinate ideas. We believe that only with interdisciplinary 
    collaboration we can arrest the design complexity and cost trend to keep up with the pace of 
    architectural innovations.
  </p>
</div>


<div id="Program" class="tabcontent">
  <h3>Program</h3>

  <table class="st" cellspacing="0" cellpadding="18" border="0">
    <colgroup valign="top">
      <col class="sl" />
      <col class="sr" />
    </colgroup>
    <tr>
        <td class="std">
          <div class="sr2">1:00-1:10pm (10mins)</div> 
        </td>
        <td class="std">
          <div class="sr1">Opening Remark </div> 
          <div class="sr2">Zhiru Zhang, Cornell University</div>
          </div>
        </td>
    </tr>

    <tr>
      <td class="std">
        <div class="sr2">1:10-1:50pm (40mins)</div> 
      </td>
      <td class="std">
        <div class="sr1">Keynote: Formal successes & frontiers in XLS' High Level Synthesis toolchain </div> 
        <div class="sr2">Chris Leary, Google</div>  
      </div>
      </td>
  </tr>

  <tr>
    <td class="std">
      <div class="sr2">1:50-2:15pm (25mins)</div> 
    </td>
    <td class="std">
      <div class="sr1">Talk: Scalable Equivalence Checking for Behavioral Synthesis</div> 
      <div class="sr2">Fei Xie, Portland State University</div>  
    </div>
    </td>
</tr>

<tr>
  <td class="std">
    <div class="sr2">2:15-2:40pm (25mins)</div> 
  </td>
  <td class="std">
    <div class="sr1">Talk: Towards A Formally Verified FHE Accelerator Design</div> 
    <div class="sr2">Jin Yang, Intel</div>  
  </div>
  </td>
</tr>
 

<tr>
  <td class="std">
    <div class="sr2">2:40-3:05pm (25mins)</div> 
  </td>
  <td class="std">
    <div class="sr1">Talk: Can We Eliminate the Performance vs. Correctness Tradeoff When Writing Low-Level HPC Code?</div> 
    <div class="sr2">Gilbert Bernstein, University of Washington</div>  
  </div>
  </td>
</tr>
 
<tr>
  <td class="std">
    <div class="sr2">3:05-3:25pm (20mins)</div> 
  </td>
  <td class="std">
    <div class="sr1">Coffee Break</div>  
  </div>
  </td>
</tr>

<tr>
  <td class="std">
    <div class="sr2">3:25-3:50pm (25mins)</div> 
  </td>
  <td class="std">
    <div class="sr1">Talk: Generalizing the ISA to the ILA: A Software/Hardware Interface for Accelerator-rich Platforms</div> 
    <div class="sr2">Sharad Malik, Princeton  University</div>  
  </div>
  </td>
</tr>

<tr>
  <td class="std">
    <div class="sr2">3:50-4:15pm (25mins)</div> 
  </td>
  <td class="std">
    <div class="sr1">Talk: Scalable Assurance via Verifiable Hardware-Software Contracts</div> 
    <div class="sr2">Caroline Trippel, Stanford University</div>  
  </div>
  </td>
</tr>

<tr>
  <td class="std">
    <div class="sr2">4:15-5:00pm (45mins)</div> 
  </td>
  <td class="std">
    <div class="sr1">Panel Discussion: Correctness Assured Accelerator Design: a Holy Grail or an Engineering Feasibility</div> 
    <div class="sr2"><b>Moderator: Debjit Pal, University of Illinois at Chicago</b></div> 
    <div class="sr2">Chris Leary, Google</div> 
    <div class="sr2">Fei Xie, Portland State University</div> 
    <div class="sr2">Jin Yang, Intel</div> 
    <div class="sr2">Gilbert Bernstein, University of Washington</div> 
    <div class="sr2">Sharad Malik, Princeton University</div> 
    <div class="sr2">Caroline Trippel, Stanford University</div> 
  </div>
  </td>
</tr>


  </table>
    


</div>



<div id="Speakers" class="tabcontent">
  <h3>Invited Speakers and Talks Details</h3>

  
<table class="st" cellspacing="0" cellpadding="18" border="0">
  <colgroup valign="top">
    <col class="sl" />
    <col class="sr" />
  </colgroup>
  <tr>
      <td class="std">
        <div class="sr1">Chris Leary</div>
        <div class="sr2">Senior Staff Software Engineer at Google</div>
      </td>
      <td class="std">
        <div class="sr1">Keynote: Formal successes & frontiers in XLS' High Level Synthesis toolchain</div>
        <div class="sr2">Abstract:
        In this talk we describe aspects of formal incorporated and explored in development of the XLS high level synthesis toolchain (github.com/google/xls). The XLS toolchain is used to design hardware blocks via a software-engineering style methodology, yet every operation in XLS' Intermediate Representation can be projected into SMTLib. This property has enabled project successes such as a proving unoptimized IR equivalent to optimized IR, HLS-to-gates Logical Equivalence Checking flow, formal verification of floating point units, and "concolic" test case generation. We'll touch on the promise of being "under the workload" in the XLS compiler, and thereby able to project the input program and annotations on it into formal models for domain-specific theorem proving. We'll also discuss the mixed promise and peril we observe for undefined behavior and exploiting user-specified assumptions. Additionally, we'll cover how this is all developed in open source using open theorem proving engines, and has tie-ins to the broader ecosystem of open hardware toolchains and PDKs that we're co-developing at Google.
        </div>
      </td>
  </tr>
  <tr>
  <td class="std">
    <div class="sr1">Caroline Trippel</div>
    <div class="sr2">Assistant Professor at Stanford University</div>
  </td>
  <td class="std">
    <div class="sr1">Invited talk: Scalable Assurance via Verifiable Hardware-Software Contracts</div>
    <div class="sr2">Abstract:
      Hardware-software (HW-SW) contracts are critical for high-assurance computer systems design and an enabler for software design/analysis tools that find and repair hardware-related bugs in programs. E.g., memory consistency models (MCMs) define what values shared memory loads can return in a parallel program. Emerging security contracts define what program data is susceptible to leakage via hardware side-channels. However, these contracts and the analyses they support are useless if we cannot guarantee microarchitectural compliance, which is a ``grand challenge.'' Notably, some contracts are still evolving e.g., security contracts), making hardware compliance a moving target. Even for mature contracts, comprehensively verifying that a complex microarchitecture implements some abstract contract is a time-consuming endeavor involving teams of engineers, which typically requires resorting to incomplete proofs.  Our work takes a radically different approach to the challenge above by synthesizing HW-SW contracts from RTL implementations. This talk will give an overview of our recent work in synthesizing formally proven-correct HW-SW contracts from RTL to support concurrency and security verification of (processor) microarchitectures.
</div>
  </td>
</tr>
<tr>
  <td class="std">
    <div class="sr1">Fei Xie</div>
    <div class="sr2">Professor at Portland State University</div>
  </td>
  <td class="std">
    <div class="sr1">Invited talk: Scalable Equivalence Checking for Behavioral Synthesis</div>
    <div class="sr2">Abstract: In this talk, we present a scalable equivalence checking framework for behavioral synthesis. Behavioral synthesis entails application of a sequence of transformations to compile a high-level description of a hardware design (e.g., in C/C++/SystemC) into a register-transfer level (RTL) implementation. Our framework covers behavioral synthesis flows end-to-end, including compiler transformations, scheduling, and binding and code generation. This framework achieves its scalability through close integration with behavioral synthesis flows.
    </div>
  </td>
</tr>

<tr>
  <td class="std">
    <div class="sr1">Gilbert Bernstein</div>
    <div class="sr2">Assistant Professor at the University of Washington</div>
  </td>
  <td class="std">
    <div class="sr1">Invited talk: Can We Eliminate the Performance vs. Correctness Tradeoff When Writing Low-Level HPC Code?</div>
    <div class="sr2">Abstract: Most applications benefiting from accelerators (especially ML accelerators) rely on hand-optimized high-performance kernel libraries to get access to new hardware, and ensure a high level of performance.  However, these kernel libraries are still written and optimized by hand, at great expense using low-level C and assembly code.  This is because the performance engineers who write this code, (like the hardware designers on the other side of the ISA from them) require control over the design.  What if we designed programming languages specially tailored to the needs of these programmers?
 <br/><br/>
      I will discuss two different “user-scheduled” languages we’ve built along these lines.  (1) Exo is an imperative language which turns the compiler “inside out” by externalizing control of code optimization directly to the user, and by replacing hardware-specific backends (the compiler writers’ responsibility) with user-level libraries (the performance engineers’ responsibility).  (2) ATL is a simple functional tensor language, which we have embedded in Coq.  Rewrites of ATL programs thereby become lemmas, and user-scheduling directives become proof tactics.  These languages match the performance of highly tuned linear algebra, neural net and image processing kernels by using formal verification machinery to expedite the existing optimization process of low-level software performance engineers.
      
  </div>
  </td>
  </tr>

  <tr>
    <td class="std">
      <div class="sr1">Jin Yang</div>
      <div class="sr2">Senior Principal Engineer at Intel Corporation</div>
    </td>
    <td class="std">
      <div class="sr1">Invited talk: Towards A Formally Verified FHE Accelerator Design</div>
      <div class="sr2">Abstract: Correctness assurance needs to be a first principle in accelerator design, especially for security and privacy applications. We will provide an overview of our approach on designing a formally verified FHE (Fully Homomorphic Encryption) accelerator. It starts with developing a behavioral micro-architecture model of the accelerator and establishing its correctness against its ISA specification by combining modular formal verification with a correct-by-construction argument similar to compiler verification. Each micro-architecture module is then refined with algorithmic details optimized for hardware implementation through a sequence of semantic preserving transformations. Finally, the functional equivalence between the refined module and its manual RTL implementation is formally verified. As a proof-of-concept, an RTL model is also automatically generated from the behavioral model through high level synthesis (HLS).
      </div>
    </td>
    </tr>

    <tr>
      <td class="std">
        <div class="sr1">Sharad Malik</div>
        <div class="sr2"> George Van Ness Lothrop Professor in Engineering at Princeton University</div>
      </td>
      <td class="std">
        <div class="sr1">Invited talk: Generalizing the ISA to the ILA: A Software/Hardware Interface for 
          Accelerator-rich Platforms
          </div>
        <div class="sr2">Abstract:
          The Instruction-Set Architecture (ISA) has long served as the software/hardware interface for programmable processors. The ISA simultaneously serves as a specification for the hardware implementation, and as an abstraction of the hardware for software development. With the advent of multiprocessors, the memory consistency model (MCM) provided the software/hardware interface for processor interactions through shared memory. We are now in an era where accelerator-rich platforms are widely used to deliver the power-performance requirements of emerging applications. Unfortunately, there is no widely accepted software/hardware interface for these platforms - this has implications for both hardware and software development. 
<br/><br/>
My group, in collaboration with others, has been working on the Instruction-Level Abstraction (ILA) as a software-hardware interface that generalizes the notion of ISAs to accelerators. The ILA model of an accelerator is a functional model that defines the response of the accelerator to commands at its interface. These commands serve as “instructions” for the accelerator. Further, we have developed the ILA-MCM model for how the operational ILA model can be integrated with an axiomatic memory consistency model for a detailed functional specification that includes accelerator-processor interactions through shared memory.
<br/><br/>
In this talk I will describe the ILA model, and its application to different use cases for accelerator-rich platforms:
<ul class="talk-description">
  <li>
Simulation and co-simulation: Show how this model enables automated generation of executable functional models (C/C++/SystemC) that can be used in hardware simulation and hardware-software co-simulation
</li><li>
Formal hardware verification: Show how the formal ILA model can be used for formal verification of the hardware implementation and hardware-software co-verification
</li><li>
Memory consistency: Show how the ILA-MCM model can be used to reason about correctness of code executing across processors and accelerators for a given MCM
</li><li>
Compilation to accelerators: Show how the ILA instructions can be used in a compiler flow targeting specialized accelerators - in particular a compiler flow for deep-learning accelerators using the TVM compiler framework.
</li>
</ul>
        </div>
      </td>
      </tr>
                              
</table>
  

</div>






<div id="Venue" class="tabcontent">
  <h3>Venue</h3>
  <p>Time: October 1st 2022 (Saturday) Afternoon 1 pm - 5 pm CDT </p>

  <p>
  Address: The Westin Chicago River North, 320 N Dearborn St, Chicago, IL 60654 
  </p>
  <iframe src="https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d2970.223359172263!2d-87.632066483536!3d41.88805327276838!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x880fae05d61b9a5d%3A0x32a4fcadac82b32a!2sThe%20Westin%20Chicago%20River%20North!5e0!3m2!1sen!2sus!4v1660805197744!5m2!1sen!2sus" width="400" height="300" style="border:0;" allowfullscreen="" loading="lazy" referrerpolicy="no-referrer-when-downgrade"></iframe>
</div>

<br>

<div id="Organizers" class="tabcontent">
  <h3>Organizers</h3>
  <ul>
    <li><b><a class="alink" href="https://www.linkedin.com/in/jin-yang-2532391/">Jin Yang</a></b>, Intel Labs, USA (co-chair)</li>
    <li><b><a class="alink" href="https://www.csl.cornell.edu/~zhiruz/">Zhiru Zhang</a></b>, Cornell University, USA (co-chair)</li>
    <li><b><a class="alink" href="https://ece.uic.edu/profiles/pal-debjit/">Debjit Pal</a></b>, University of Illinois at Chicago, USA (co-chair)</li>
    <li><b><a class="alink" href="https://caslab.csl.yale.edu/~wen/">Wen Wang</a></b>, Intel Labs, USA (co-chair)</li>
  </ul>
</div>


<!--<p>I'm hosted with GitHub Pages.</p>-->


</body>
</html>
